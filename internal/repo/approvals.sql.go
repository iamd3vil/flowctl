// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: approvals.sql

package repo

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const addApprovalRequest = `-- name: AddApprovalRequest :one
WITH inserted_approval AS (
    INSERT INTO approvals (
        exec_log_id,
        approvers,
        action_id
    ) VALUES (
        $1, $2, $3
    ) RETURNING id, uuid, exec_log_id, action_id, status, approvers, decided_by, created_at, updated_at
)
SELECT
    a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.approvers, a.decided_by, a.created_at, a.updated_at,
    u.name as requested_by
FROM inserted_approval a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN users u ON el.triggered_by = u.id
`

type AddApprovalRequestParams struct {
	ExecLogID int32           `db:"exec_log_id" json:"exec_log_id"`
	Approvers json.RawMessage `db:"approvers" json:"approvers"`
	ActionID  string          `db:"action_id" json:"action_id"`
}

type AddApprovalRequestRow struct {
	ID          int32           `db:"id" json:"id"`
	Uuid        uuid.UUID       `db:"uuid" json:"uuid"`
	ExecLogID   int32           `db:"exec_log_id" json:"exec_log_id"`
	ActionID    string          `db:"action_id" json:"action_id"`
	Status      ApprovalStatus  `db:"status" json:"status"`
	Approvers   json.RawMessage `db:"approvers" json:"approvers"`
	DecidedBy   sql.NullInt32   `db:"decided_by" json:"decided_by"`
	CreatedAt   time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`
	RequestedBy string          `db:"requested_by" json:"requested_by"`
}

func (q *Queries) AddApprovalRequest(ctx context.Context, arg AddApprovalRequestParams) (AddApprovalRequestRow, error) {
	row := q.db.QueryRowContext(ctx, addApprovalRequest, arg.ExecLogID, arg.Approvers, arg.ActionID)
	var i AddApprovalRequestRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.Approvers,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequestedBy,
	)
	return i, err
}

const approveRequestByUUID = `-- name: ApproveRequestByUUID :one
WITH namespace_lookup AS (
    SELECT id FROM namespaces WHERE namespaces.uuid = $3
), updated AS (
    UPDATE approvals SET status = 'approved', decided_by = $2, updated_at = NOW()
    WHERE approvals.uuid = $1 
    AND approvals.exec_log_id IN (
        SELECT el.id FROM execution_log el
        JOIN flows f ON el.flow_id = f.id
        WHERE f.namespace_id = (SELECT id FROM namespace_lookup)
    )
    RETURNING id, uuid, exec_log_id, action_id, status, approvers, decided_by, created_at, updated_at
)
SELECT
    a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.approvers, a.decided_by, a.created_at, a.updated_at,
    u.name as requested_by
FROM updated a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN users u ON el.triggered_by = u.id
`

type ApproveRequestByUUIDParams struct {
	Uuid      uuid.UUID     `db:"uuid" json:"uuid"`
	DecidedBy sql.NullInt32 `db:"decided_by" json:"decided_by"`
	Uuid_2    uuid.UUID     `db:"uuid_2" json:"uuid_2"`
}

type ApproveRequestByUUIDRow struct {
	ID          int32           `db:"id" json:"id"`
	Uuid        uuid.UUID       `db:"uuid" json:"uuid"`
	ExecLogID   int32           `db:"exec_log_id" json:"exec_log_id"`
	ActionID    string          `db:"action_id" json:"action_id"`
	Status      ApprovalStatus  `db:"status" json:"status"`
	Approvers   json.RawMessage `db:"approvers" json:"approvers"`
	DecidedBy   sql.NullInt32   `db:"decided_by" json:"decided_by"`
	CreatedAt   time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`
	RequestedBy string          `db:"requested_by" json:"requested_by"`
}

func (q *Queries) ApproveRequestByUUID(ctx context.Context, arg ApproveRequestByUUIDParams) (ApproveRequestByUUIDRow, error) {
	row := q.db.QueryRowContext(ctx, approveRequestByUUID, arg.Uuid, arg.DecidedBy, arg.Uuid_2)
	var i ApproveRequestByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.Approvers,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequestedBy,
	)
	return i, err
}

const getApprovalByUUID = `-- name: GetApprovalByUUID :one
WITH namespace_lookup AS (
    SELECT id FROM namespaces WHERE namespaces.uuid = $2
)
SELECT
    a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.approvers, a.decided_by, a.created_at, a.updated_at,
    u.name as requested_by
FROM approvals a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN flows f ON el.flow_id = f.id
JOIN users u ON el.triggered_by = u.id
WHERE a.uuid = $1 AND f.namespace_id = (SELECT id FROM namespace_lookup)
`

type GetApprovalByUUIDParams struct {
	Uuid   uuid.UUID `db:"uuid" json:"uuid"`
	Uuid_2 uuid.UUID `db:"uuid_2" json:"uuid_2"`
}

type GetApprovalByUUIDRow struct {
	ID          int32           `db:"id" json:"id"`
	Uuid        uuid.UUID       `db:"uuid" json:"uuid"`
	ExecLogID   int32           `db:"exec_log_id" json:"exec_log_id"`
	ActionID    string          `db:"action_id" json:"action_id"`
	Status      ApprovalStatus  `db:"status" json:"status"`
	Approvers   json.RawMessage `db:"approvers" json:"approvers"`
	DecidedBy   sql.NullInt32   `db:"decided_by" json:"decided_by"`
	CreatedAt   time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`
	RequestedBy string          `db:"requested_by" json:"requested_by"`
}

func (q *Queries) GetApprovalByUUID(ctx context.Context, arg GetApprovalByUUIDParams) (GetApprovalByUUIDRow, error) {
	row := q.db.QueryRowContext(ctx, getApprovalByUUID, arg.Uuid, arg.Uuid_2)
	var i GetApprovalByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.Approvers,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequestedBy,
	)
	return i, err
}

const getApprovalRequestForActionAndExec = `-- name: GetApprovalRequestForActionAndExec :one
WITH exec_lookup AS (
    SELECT id FROM execution_log WHERE execution_log.exec_id = $1
), namespace_lookup AS (
    SELECT id FROM namespaces WHERE namespaces.uuid = $3
)
SELECT a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.approvers, a.decided_by, a.created_at, a.updated_at FROM approvals a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN flows f ON el.flow_id = f.id
WHERE a.exec_log_id = (SELECT id FROM exec_lookup) 
  AND a.action_id = $2
  AND f.namespace_id = (SELECT id FROM namespace_lookup)
`

type GetApprovalRequestForActionAndExecParams struct {
	ExecID   string    `db:"exec_id" json:"exec_id"`
	ActionID string    `db:"action_id" json:"action_id"`
	Uuid     uuid.UUID `db:"uuid" json:"uuid"`
}

func (q *Queries) GetApprovalRequestForActionAndExec(ctx context.Context, arg GetApprovalRequestForActionAndExecParams) (Approval, error) {
	row := q.db.QueryRowContext(ctx, getApprovalRequestForActionAndExec, arg.ExecID, arg.ActionID, arg.Uuid)
	var i Approval
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.Approvers,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingApprovalRequestForExec = `-- name: GetPendingApprovalRequestForExec :one
WITH exec_lookup AS (
    SELECT id FROM execution_log WHERE execution_log.exec_id = $1
), namespace_lookup AS (
    SELECT id FROM namespaces WHERE namespaces.uuid = $2
)
SELECT
    a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.approvers, a.decided_by, a.created_at, a.updated_at,
    u.name as requested_by
FROM approvals a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN flows f ON el.flow_id = f.id
JOIN users u ON el.triggered_by = u.id
WHERE a.exec_log_id = (SELECT id FROM exec_lookup) 
  AND a.status = 'pending'
  AND f.namespace_id = (SELECT id FROM namespace_lookup)
`

type GetPendingApprovalRequestForExecParams struct {
	ExecID string    `db:"exec_id" json:"exec_id"`
	Uuid   uuid.UUID `db:"uuid" json:"uuid"`
}

type GetPendingApprovalRequestForExecRow struct {
	ID          int32           `db:"id" json:"id"`
	Uuid        uuid.UUID       `db:"uuid" json:"uuid"`
	ExecLogID   int32           `db:"exec_log_id" json:"exec_log_id"`
	ActionID    string          `db:"action_id" json:"action_id"`
	Status      ApprovalStatus  `db:"status" json:"status"`
	Approvers   json.RawMessage `db:"approvers" json:"approvers"`
	DecidedBy   sql.NullInt32   `db:"decided_by" json:"decided_by"`
	CreatedAt   time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`
	RequestedBy string          `db:"requested_by" json:"requested_by"`
}

func (q *Queries) GetPendingApprovalRequestForExec(ctx context.Context, arg GetPendingApprovalRequestForExecParams) (GetPendingApprovalRequestForExecRow, error) {
	row := q.db.QueryRowContext(ctx, getPendingApprovalRequestForExec, arg.ExecID, arg.Uuid)
	var i GetPendingApprovalRequestForExecRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.Approvers,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequestedBy,
	)
	return i, err
}

const rejectRequestByUUID = `-- name: RejectRequestByUUID :one
WITH namespace_lookup AS (
    SELECT id FROM namespaces WHERE namespaces.uuid = $3
), updated AS (
    UPDATE approvals SET status = 'rejected', decided_by = $2, updated_at = NOW()
    WHERE approvals.uuid = $1
    AND approvals.exec_log_id IN (
        SELECT el.id FROM execution_log el
        JOIN flows f ON el.flow_id = f.id
        WHERE f.namespace_id = (SELECT id FROM namespace_lookup)
    )
    RETURNING id, uuid, exec_log_id, action_id, status, approvers, decided_by, created_at, updated_at
)
SELECT
    a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.approvers, a.decided_by, a.created_at, a.updated_at,
    u.name as requested_by
FROM updated a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN users u ON el.triggered_by = u.id
`

type RejectRequestByUUIDParams struct {
	Uuid      uuid.UUID     `db:"uuid" json:"uuid"`
	DecidedBy sql.NullInt32 `db:"decided_by" json:"decided_by"`
	Uuid_2    uuid.UUID     `db:"uuid_2" json:"uuid_2"`
}

type RejectRequestByUUIDRow struct {
	ID          int32           `db:"id" json:"id"`
	Uuid        uuid.UUID       `db:"uuid" json:"uuid"`
	ExecLogID   int32           `db:"exec_log_id" json:"exec_log_id"`
	ActionID    string          `db:"action_id" json:"action_id"`
	Status      ApprovalStatus  `db:"status" json:"status"`
	Approvers   json.RawMessage `db:"approvers" json:"approvers"`
	DecidedBy   sql.NullInt32   `db:"decided_by" json:"decided_by"`
	CreatedAt   time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`
	RequestedBy string          `db:"requested_by" json:"requested_by"`
}

func (q *Queries) RejectRequestByUUID(ctx context.Context, arg RejectRequestByUUIDParams) (RejectRequestByUUIDRow, error) {
	row := q.db.QueryRowContext(ctx, rejectRequestByUUID, arg.Uuid, arg.DecidedBy, arg.Uuid_2)
	var i RejectRequestByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.Approvers,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequestedBy,
	)
	return i, err
}

const updateApprovalStatusByUUID = `-- name: UpdateApprovalStatusByUUID :one
WITH updated AS (
    UPDATE approvals SET status = $1, decided_by = $2, updated_at = NOW()
    WHERE uuid = $1
    RETURNING id, uuid, exec_log_id, action_id, status, approvers, decided_by, created_at, updated_at
)
SELECT
    a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.approvers, a.decided_by, a.created_at, a.updated_at,
    u.name as requested_by
FROM updated a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN users u ON el.triggered_by = u.id
`

type UpdateApprovalStatusByUUIDParams struct {
	Status    ApprovalStatus `db:"status" json:"status"`
	DecidedBy sql.NullInt32  `db:"decided_by" json:"decided_by"`
}

type UpdateApprovalStatusByUUIDRow struct {
	ID          int32           `db:"id" json:"id"`
	Uuid        uuid.UUID       `db:"uuid" json:"uuid"`
	ExecLogID   int32           `db:"exec_log_id" json:"exec_log_id"`
	ActionID    string          `db:"action_id" json:"action_id"`
	Status      ApprovalStatus  `db:"status" json:"status"`
	Approvers   json.RawMessage `db:"approvers" json:"approvers"`
	DecidedBy   sql.NullInt32   `db:"decided_by" json:"decided_by"`
	CreatedAt   time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`
	RequestedBy string          `db:"requested_by" json:"requested_by"`
}

func (q *Queries) UpdateApprovalStatusByUUID(ctx context.Context, arg UpdateApprovalStatusByUUIDParams) (UpdateApprovalStatusByUUIDRow, error) {
	row := q.db.QueryRowContext(ctx, updateApprovalStatusByUUID, arg.Status, arg.DecidedBy)
	var i UpdateApprovalStatusByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.Approvers,
		&i.DecidedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequestedBy,
	)
	return i, err
}
