// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: approvals.sql

package repo

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const addApprovalRequest = `-- name: AddApprovalRequest :one
WITH inserted_approval AS (
    INSERT INTO approvals (
        exec_log_id,
        action_id,
        namespace_id
    ) VALUES (
        $1, $2, (SELECT id FROM namespaces where namespaces.uuid = $3)
    ) RETURNING id, uuid, exec_log_id, action_id, status, decided_by, namespace_id, created_at, updated_at
)
SELECT
    a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.decided_by, a.namespace_id, a.created_at, a.updated_at,
    u.name as requested_by
FROM inserted_approval a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN users u ON el.triggered_by = u.id
`

type AddApprovalRequestParams struct {
	ExecLogID int32     `db:"exec_log_id" json:"exec_log_id"`
	ActionID  string    `db:"action_id" json:"action_id"`
	Uuid      uuid.UUID `db:"uuid" json:"uuid"`
}

type AddApprovalRequestRow struct {
	ID          int32          `db:"id" json:"id"`
	Uuid        uuid.UUID      `db:"uuid" json:"uuid"`
	ExecLogID   int32          `db:"exec_log_id" json:"exec_log_id"`
	ActionID    string         `db:"action_id" json:"action_id"`
	Status      ApprovalStatus `db:"status" json:"status"`
	DecidedBy   sql.NullInt32  `db:"decided_by" json:"decided_by"`
	NamespaceID int32          `db:"namespace_id" json:"namespace_id"`
	CreatedAt   time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time      `db:"updated_at" json:"updated_at"`
	RequestedBy string         `db:"requested_by" json:"requested_by"`
}

func (q *Queries) AddApprovalRequest(ctx context.Context, arg AddApprovalRequestParams) (AddApprovalRequestRow, error) {
	row := q.db.QueryRowContext(ctx, addApprovalRequest, arg.ExecLogID, arg.ActionID, arg.Uuid)
	var i AddApprovalRequestRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.DecidedBy,
		&i.NamespaceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequestedBy,
	)
	return i, err
}

const approveRequestByUUID = `-- name: ApproveRequestByUUID :one
WITH namespace_lookup AS (
    SELECT id FROM namespaces WHERE namespaces.uuid = $3
), updated AS (
    UPDATE approvals SET status = 'approved', decided_by = $2, updated_at = NOW()
    WHERE approvals.uuid = $1
    AND approvals.exec_log_id IN (
        SELECT el.id FROM execution_log el
        JOIN flows f ON el.flow_id = f.id
        WHERE f.namespace_id = (SELECT id FROM namespace_lookup) AND f.is_active = TRUE
    )
    RETURNING id, uuid, exec_log_id, action_id, status, decided_by, namespace_id, created_at, updated_at
)
SELECT
    a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.decided_by, a.namespace_id, a.created_at, a.updated_at,
    u.name as requested_by
FROM updated a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN users u ON el.triggered_by = u.id
`

type ApproveRequestByUUIDParams struct {
	Uuid      uuid.UUID     `db:"uuid" json:"uuid"`
	DecidedBy sql.NullInt32 `db:"decided_by" json:"decided_by"`
	Uuid_2    uuid.UUID     `db:"uuid_2" json:"uuid_2"`
}

type ApproveRequestByUUIDRow struct {
	ID          int32          `db:"id" json:"id"`
	Uuid        uuid.UUID      `db:"uuid" json:"uuid"`
	ExecLogID   int32          `db:"exec_log_id" json:"exec_log_id"`
	ActionID    string         `db:"action_id" json:"action_id"`
	Status      ApprovalStatus `db:"status" json:"status"`
	DecidedBy   sql.NullInt32  `db:"decided_by" json:"decided_by"`
	NamespaceID int32          `db:"namespace_id" json:"namespace_id"`
	CreatedAt   time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time      `db:"updated_at" json:"updated_at"`
	RequestedBy string         `db:"requested_by" json:"requested_by"`
}

func (q *Queries) ApproveRequestByUUID(ctx context.Context, arg ApproveRequestByUUIDParams) (ApproveRequestByUUIDRow, error) {
	row := q.db.QueryRowContext(ctx, approveRequestByUUID, arg.Uuid, arg.DecidedBy, arg.Uuid_2)
	var i ApproveRequestByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.DecidedBy,
		&i.NamespaceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequestedBy,
	)
	return i, err
}

const getApprovalByUUID = `-- name: GetApprovalByUUID :one
WITH namespace_lookup AS (
    SELECT id FROM namespaces WHERE namespaces.uuid = $2
)
SELECT
    a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.decided_by, a.namespace_id, a.created_at, a.updated_at,
    el.exec_id,
    u.name as requested_by
FROM approvals a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN flows f ON el.flow_id = f.id
JOIN users u ON el.triggered_by = u.id
WHERE a.uuid = $1 AND f.namespace_id = (SELECT id FROM namespace_lookup) AND f.is_active = TRUE
`

type GetApprovalByUUIDParams struct {
	Uuid   uuid.UUID `db:"uuid" json:"uuid"`
	Uuid_2 uuid.UUID `db:"uuid_2" json:"uuid_2"`
}

type GetApprovalByUUIDRow struct {
	ID          int32          `db:"id" json:"id"`
	Uuid        uuid.UUID      `db:"uuid" json:"uuid"`
	ExecLogID   int32          `db:"exec_log_id" json:"exec_log_id"`
	ActionID    string         `db:"action_id" json:"action_id"`
	Status      ApprovalStatus `db:"status" json:"status"`
	DecidedBy   sql.NullInt32  `db:"decided_by" json:"decided_by"`
	NamespaceID int32          `db:"namespace_id" json:"namespace_id"`
	CreatedAt   time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time      `db:"updated_at" json:"updated_at"`
	ExecID      string         `db:"exec_id" json:"exec_id"`
	RequestedBy string         `db:"requested_by" json:"requested_by"`
}

func (q *Queries) GetApprovalByUUID(ctx context.Context, arg GetApprovalByUUIDParams) (GetApprovalByUUIDRow, error) {
	row := q.db.QueryRowContext(ctx, getApprovalByUUID, arg.Uuid, arg.Uuid_2)
	var i GetApprovalByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.DecidedBy,
		&i.NamespaceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExecID,
		&i.RequestedBy,
	)
	return i, err
}

const getApprovalRequestForActionAndExec = `-- name: GetApprovalRequestForActionAndExec :one
WITH namespace_lookup AS (
    SELECT id FROM namespaces WHERE namespaces.uuid = $3
)
SELECT a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.decided_by, a.namespace_id, a.created_at, a.updated_at FROM approvals a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN flows f ON el.flow_id = f.id
WHERE el.exec_id = $1
  AND a.action_id = $2
  AND f.namespace_id = (SELECT id FROM namespace_lookup)
  AND f.is_active = TRUE
`

type GetApprovalRequestForActionAndExecParams struct {
	ExecID   string    `db:"exec_id" json:"exec_id"`
	ActionID string    `db:"action_id" json:"action_id"`
	Uuid     uuid.UUID `db:"uuid" json:"uuid"`
}

func (q *Queries) GetApprovalRequestForActionAndExec(ctx context.Context, arg GetApprovalRequestForActionAndExecParams) (Approval, error) {
	row := q.db.QueryRowContext(ctx, getApprovalRequestForActionAndExec, arg.ExecID, arg.ActionID, arg.Uuid)
	var i Approval
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.DecidedBy,
		&i.NamespaceID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getApprovalRequestForExec = `-- name: GetApprovalRequestForExec :one
WITH namespace_lookup AS (
    SELECT id FROM namespaces WHERE namespaces.uuid = $2
), latest_version AS (
    SELECT MAX(version) as max_version
    FROM execution_log
    WHERE exec_id = $1
      AND namespace_id = (SELECT id FROM namespace_lookup)
)
SELECT
    a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.decided_by, a.namespace_id, a.created_at, a.updated_at,
    el.exec_id,
    u.name as requested_by
FROM approvals a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN flows f ON el.flow_id = f.id
JOIN users u ON el.triggered_by = u.id
WHERE el.exec_id = $1
  AND f.namespace_id = (SELECT id FROM namespace_lookup)
  AND el.version = (SELECT max_version FROM latest_version)
  AND f.is_active = TRUE
`

type GetApprovalRequestForExecParams struct {
	ExecID string    `db:"exec_id" json:"exec_id"`
	Uuid   uuid.UUID `db:"uuid" json:"uuid"`
}

type GetApprovalRequestForExecRow struct {
	ID          int32          `db:"id" json:"id"`
	Uuid        uuid.UUID      `db:"uuid" json:"uuid"`
	ExecLogID   int32          `db:"exec_log_id" json:"exec_log_id"`
	ActionID    string         `db:"action_id" json:"action_id"`
	Status      ApprovalStatus `db:"status" json:"status"`
	DecidedBy   sql.NullInt32  `db:"decided_by" json:"decided_by"`
	NamespaceID int32          `db:"namespace_id" json:"namespace_id"`
	CreatedAt   time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time      `db:"updated_at" json:"updated_at"`
	ExecID      string         `db:"exec_id" json:"exec_id"`
	RequestedBy string         `db:"requested_by" json:"requested_by"`
}

func (q *Queries) GetApprovalRequestForExec(ctx context.Context, arg GetApprovalRequestForExecParams) (GetApprovalRequestForExecRow, error) {
	row := q.db.QueryRowContext(ctx, getApprovalRequestForExec, arg.ExecID, arg.Uuid)
	var i GetApprovalRequestForExecRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.DecidedBy,
		&i.NamespaceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExecID,
		&i.RequestedBy,
	)
	return i, err
}

const getApprovalWithInputsByUUID = `-- name: GetApprovalWithInputsByUUID :one
WITH namespace_lookup AS (
    SELECT id FROM namespaces WHERE namespaces.uuid = $2
)
SELECT
    a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.decided_by, a.namespace_id, a.created_at, a.updated_at,
    el.exec_id,
    el.input as exec_inputs,
    f.name as flow_name,
    f.slug as flow_slug,
    u.name as requested_by,
    us.name as decided_by_name
FROM approvals a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN flows f ON el.flow_id = f.id
JOIN users u ON el.triggered_by = u.id
LEFT JOIN users us ON a.decided_by = us.id
WHERE a.uuid = $1 AND f.namespace_id = (SELECT id FROM namespace_lookup) AND f.is_active = TRUE
`

type GetApprovalWithInputsByUUIDParams struct {
	Uuid   uuid.UUID `db:"uuid" json:"uuid"`
	Uuid_2 uuid.UUID `db:"uuid_2" json:"uuid_2"`
}

type GetApprovalWithInputsByUUIDRow struct {
	ID            int32           `db:"id" json:"id"`
	Uuid          uuid.UUID       `db:"uuid" json:"uuid"`
	ExecLogID     int32           `db:"exec_log_id" json:"exec_log_id"`
	ActionID      string          `db:"action_id" json:"action_id"`
	Status        ApprovalStatus  `db:"status" json:"status"`
	DecidedBy     sql.NullInt32   `db:"decided_by" json:"decided_by"`
	NamespaceID   int32           `db:"namespace_id" json:"namespace_id"`
	CreatedAt     time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt     time.Time       `db:"updated_at" json:"updated_at"`
	ExecID        string          `db:"exec_id" json:"exec_id"`
	ExecInputs    json.RawMessage `db:"exec_inputs" json:"exec_inputs"`
	FlowName      string          `db:"flow_name" json:"flow_name"`
	FlowSlug      string          `db:"flow_slug" json:"flow_slug"`
	RequestedBy   string          `db:"requested_by" json:"requested_by"`
	DecidedByName sql.NullString  `db:"decided_by_name" json:"decided_by_name"`
}

func (q *Queries) GetApprovalWithInputsByUUID(ctx context.Context, arg GetApprovalWithInputsByUUIDParams) (GetApprovalWithInputsByUUIDRow, error) {
	row := q.db.QueryRowContext(ctx, getApprovalWithInputsByUUID, arg.Uuid, arg.Uuid_2)
	var i GetApprovalWithInputsByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.DecidedBy,
		&i.NamespaceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExecID,
		&i.ExecInputs,
		&i.FlowName,
		&i.FlowSlug,
		&i.RequestedBy,
		&i.DecidedByName,
	)
	return i, err
}

const getApprovalsPaginated = `-- name: GetApprovalsPaginated :many
WITH namespace_lookup AS (
    SELECT id FROM namespaces WHERE namespaces.uuid = $1
),
filtered AS (
    SELECT
        a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.decided_by, a.namespace_id, a.created_at, a.updated_at,
        el.exec_id,
        u.name as requested_by,
        f.name as flow_name
    FROM approvals a
    JOIN execution_log el ON a.exec_log_id = el.id
    JOIN flows f ON el.flow_id = f.id
    JOIN users u ON el.triggered_by = u.id
    WHERE f.namespace_id = (SELECT id FROM namespace_lookup)
      AND f.is_active = TRUE
      AND (CASE WHEN $2::text = '' THEN TRUE ELSE a.status = $2::approval_status END)
      AND (
        $3 = '' OR
        a.action_id ILIKE '%' || $3 || '%' OR
        el.exec_id ILIKE '%' || $3 || '%' OR
        u.name ILIKE '%' || $3 || '%'
      )
),
total AS (
    SELECT COUNT(*) AS total_count
    FROM filtered
),
paged AS (
    SELECT id, uuid, exec_log_id, action_id, status, decided_by, namespace_id, created_at, updated_at, exec_id, requested_by, flow_name
    FROM filtered
    ORDER BY created_at DESC
    LIMIT $4 OFFSET $5
),
page_count AS (
    SELECT CEIL(total.total_count::numeric / $4::numeric)::bigint AS page_count
    FROM total
)
SELECT
    p.id, p.uuid, p.exec_log_id, p.action_id, p.status, p.decided_by, p.namespace_id, p.created_at, p.updated_at, p.exec_id, p.requested_by, p.flow_name,
    pc.page_count,
    t.total_count
FROM paged p, page_count pc, total t
`

type GetApprovalsPaginatedParams struct {
	Uuid    uuid.UUID   `db:"uuid" json:"uuid"`
	Column2 string      `db:"column_2" json:"column_2"`
	Column3 interface{} `db:"column_3" json:"column_3"`
	Limit   int32       `db:"limit" json:"limit"`
	Offset  int32       `db:"offset" json:"offset"`
}

type GetApprovalsPaginatedRow struct {
	ID          int32          `db:"id" json:"id"`
	Uuid        uuid.UUID      `db:"uuid" json:"uuid"`
	ExecLogID   int32          `db:"exec_log_id" json:"exec_log_id"`
	ActionID    string         `db:"action_id" json:"action_id"`
	Status      ApprovalStatus `db:"status" json:"status"`
	DecidedBy   sql.NullInt32  `db:"decided_by" json:"decided_by"`
	NamespaceID int32          `db:"namespace_id" json:"namespace_id"`
	CreatedAt   time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time      `db:"updated_at" json:"updated_at"`
	ExecID      string         `db:"exec_id" json:"exec_id"`
	RequestedBy string         `db:"requested_by" json:"requested_by"`
	FlowName    string         `db:"flow_name" json:"flow_name"`
	PageCount   int64          `db:"page_count" json:"page_count"`
	TotalCount  int64          `db:"total_count" json:"total_count"`
}

func (q *Queries) GetApprovalsPaginated(ctx context.Context, arg GetApprovalsPaginatedParams) ([]GetApprovalsPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getApprovalsPaginated,
		arg.Uuid,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetApprovalsPaginatedRow
	for rows.Next() {
		var i GetApprovalsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.ExecLogID,
			&i.ActionID,
			&i.Status,
			&i.DecidedBy,
			&i.NamespaceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ExecID,
			&i.RequestedBy,
			&i.FlowName,
			&i.PageCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectRequestByUUID = `-- name: RejectRequestByUUID :one
WITH namespace_lookup AS (
    SELECT id FROM namespaces WHERE namespaces.uuid = $3
), updated AS (
    UPDATE approvals SET status = 'rejected', decided_by = $2, updated_at = NOW()
    WHERE approvals.uuid = $1
    AND approvals.exec_log_id IN (
        SELECT el.id FROM execution_log el
        JOIN flows f ON el.flow_id = f.id
        WHERE f.namespace_id = (SELECT id FROM namespace_lookup) AND f.is_active = TRUE
    )
    RETURNING id, uuid, exec_log_id, action_id, status, decided_by, namespace_id, created_at, updated_at
)
SELECT
    a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.decided_by, a.namespace_id, a.created_at, a.updated_at,
    el.exec_id,
    u.name as requested_by
FROM updated a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN users u ON el.triggered_by = u.id
`

type RejectRequestByUUIDParams struct {
	Uuid      uuid.UUID     `db:"uuid" json:"uuid"`
	DecidedBy sql.NullInt32 `db:"decided_by" json:"decided_by"`
	Uuid_2    uuid.UUID     `db:"uuid_2" json:"uuid_2"`
}

type RejectRequestByUUIDRow struct {
	ID          int32          `db:"id" json:"id"`
	Uuid        uuid.UUID      `db:"uuid" json:"uuid"`
	ExecLogID   int32          `db:"exec_log_id" json:"exec_log_id"`
	ActionID    string         `db:"action_id" json:"action_id"`
	Status      ApprovalStatus `db:"status" json:"status"`
	DecidedBy   sql.NullInt32  `db:"decided_by" json:"decided_by"`
	NamespaceID int32          `db:"namespace_id" json:"namespace_id"`
	CreatedAt   time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time      `db:"updated_at" json:"updated_at"`
	ExecID      string         `db:"exec_id" json:"exec_id"`
	RequestedBy string         `db:"requested_by" json:"requested_by"`
}

func (q *Queries) RejectRequestByUUID(ctx context.Context, arg RejectRequestByUUIDParams) (RejectRequestByUUIDRow, error) {
	row := q.db.QueryRowContext(ctx, rejectRequestByUUID, arg.Uuid, arg.DecidedBy, arg.Uuid_2)
	var i RejectRequestByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.DecidedBy,
		&i.NamespaceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ExecID,
		&i.RequestedBy,
	)
	return i, err
}

const updateApprovalStatusByUUID = `-- name: UpdateApprovalStatusByUUID :one
WITH updated AS (
    UPDATE approvals SET status = $1, decided_by = $2, updated_at = NOW()
    WHERE uuid = $1
    RETURNING id, uuid, exec_log_id, action_id, status, decided_by, namespace_id, created_at, updated_at
)
SELECT
    a.id, a.uuid, a.exec_log_id, a.action_id, a.status, a.decided_by, a.namespace_id, a.created_at, a.updated_at,
    u.name as requested_by
FROM updated a
JOIN execution_log el ON a.exec_log_id = el.id
JOIN users u ON el.triggered_by = u.id
`

type UpdateApprovalStatusByUUIDParams struct {
	Status    ApprovalStatus `db:"status" json:"status"`
	DecidedBy sql.NullInt32  `db:"decided_by" json:"decided_by"`
}

type UpdateApprovalStatusByUUIDRow struct {
	ID          int32          `db:"id" json:"id"`
	Uuid        uuid.UUID      `db:"uuid" json:"uuid"`
	ExecLogID   int32          `db:"exec_log_id" json:"exec_log_id"`
	ActionID    string         `db:"action_id" json:"action_id"`
	Status      ApprovalStatus `db:"status" json:"status"`
	DecidedBy   sql.NullInt32  `db:"decided_by" json:"decided_by"`
	NamespaceID int32          `db:"namespace_id" json:"namespace_id"`
	CreatedAt   time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time      `db:"updated_at" json:"updated_at"`
	RequestedBy string         `db:"requested_by" json:"requested_by"`
}

func (q *Queries) UpdateApprovalStatusByUUID(ctx context.Context, arg UpdateApprovalStatusByUUIDParams) (UpdateApprovalStatusByUUIDRow, error) {
	row := q.db.QueryRowContext(ctx, updateApprovalStatusByUUID, arg.Status, arg.DecidedBy)
	var i UpdateApprovalStatusByUUIDRow
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.ExecLogID,
		&i.ActionID,
		&i.Status,
		&i.DecidedBy,
		&i.NamespaceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequestedBy,
	)
	return i, err
}
